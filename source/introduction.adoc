= Introduction

Being a developer isn't easy.
While it's a challenge which we love, it's still a tough gig.
Why?
Because there are so many things to learn.

From frameworks and software design patterns, to deployment and scaling techniques, to testing, security, and performance demands.
Our time's stretched thin staying abreast of all of these tasks.
Yet somehow we manage.
Somehow, we keep our heads above water and survive.

Given all this, the last thing we want to do is waste our precious time on anything which isn't productive.
And two things which aren't productive are:

. Setting up development environments which match remote environments
. Deploying our code to those remote environments

So why in this modern day and age can doing both of these tasks still be such a complicated process?
Why is it still so hard to get one setup that works, that does what you need, and that matches the deployment environment's of testing, staging, production and so on?

Think back to when you first began hacking with PHP code.
Depending when that was, you likely started off using the native tools available on your operating system of choice.

If you're a Linux user, you likely installed PHP, then Apache or NGINX, and MySQL, or maybe you went with PostgreSQL instead, using the native package manager.
After a little while, of managing everything on your own, in an attempt to "outsource" the overhead, you likely tried one of the *AMP stacks, such as LAMP, MAMP, and WAMP.

However, as wonderful as these tools are, you invariably outgrew them at some point.
Here, you might have progressed on to something more fluid and flexible, such as Vagrant & VirtualBox VM's—after learning one (or more) provisioning tools, such as Chef, Puppet, or Ansible.

Given all of this knowledge and experience, your development environments have grown quite sophisticated.
However, the overhead of both building and maintaining them has increased significantly as well.

Wouldn't it be easy if we could set them up, but with only a small investment of time and effort?
I think you know where I might be heading with this.
With Docker, you can.

That's why I wrote this short guide!

== Enter Docker

image::docker_logo.png[Docker Logo]

That's right - https://www.docker.com/)[Docker].
Docker was initially released back in March of 2013 by a hosting company called dotCloud.
dotCloud had been using the tool internally to make their lives easier managing their hosting business.

https://en.wikipedia.org/wiki/Docker_(software)[To quote Wikipedia:]

[quote]
Docker is an open-source project that automates the deployment of Linux applications inside software containers.

Here's a longer description:

[quote]
Docker containers wrap up a piece of software in a complete filesystem that contains everything it needs to run: code, runtime, system tools, system libraries—anything you can install on a server.
This guarantees that it will always execute the same, regardless of the environment it is running in.

== Docker Is Simpler

Now you might be thinking that this all sounds similar to everything else you've used, such as a LAMP stack or a Vagrant/VirtualBox VM.

In a way it is.
But it's also a lot less resource and time intensive.
As the quote above summarizes, Docker contains—and uses—*only* what it needs to run your application—nothing more.

You're not building a big virtual machine which will consume a good chunk of your development machine's resources.
You don't have to learn—and write—massive configuration setups to build a basic, working, setup.

You don't need to do much at all to get your up and running.
Docker allows you to build your application infrastructure, as you would your code.
You determine the parts and services you need and stack them together like Lego blocks.

If you need to change your web server or database server, then switch the current one out for another.
Need to add a caching, logging, or queueing server?
Add it into the mix and keep on going.
It is that simple.

Sound enticing?
I hope so.

== Why This Book?

== Who Is This Book For?

