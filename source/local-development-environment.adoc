= How To Build a Local Development Environment Using Docker

Building a development environment which mirrors production (or any other environment) hasn't, historically, been an easy task.
But with Docker, it's become, _almost_, trivial.
In this chapter, I'll step you through how to setup a local development environment using Docker for developing PHP applications.

[NOTE] 
====
The code that I use in this chapter (and the rest of the book) will be based on the Mezzio framework.
However, feel free to substitute an application of your choosing, should you prefer that.
====

== How to Build a Development Environment with Docker

If you're keen to find out the latest, and best, way to create a development environment, one which you can be up and running within less than 20 minutes, let's get started.

In this tutorial I'm going to show you how to build a local development setup, using Docker, to run a Zend Expressive app, https://matthewsetter.com/zend-expressive-introduction[based on the Zend Expressive Skeleton Installer].

NOTE: It would likely work for any Zend Expressive, or PHP, application for that matter.

Here's how it will work;
we'll have one container for PHP, one container for Nginx, and one container for MySQL.
Our configuration will bind them altogether so that, when finished, we can run one command line script to build it, boot it, and view it locally on port 8080.

Let's begin.

NOTE: This is not an extensive tutorial on Docker.
If you want to learn all there is to know, I strongly encourage you to check out either https://learningcontainers.com/?utm_source=masterzendframework&utm_medium=link&utm_campaign=learningcontainers[Learning Containers], by Chris Tankersley, http://shippingdocker.com/[Shipping Docker] by Chris Fidao, or buy https://leanpub.com/dockerfordevs?utm_source=masterzendframework&utm_medium=link&utm_campaign=dockerfordevs[Docker for Developers].
They're all excellent resources!

== Installing Docker

image::docker-install-options.png[Docker Install Options]

I'll assume that you don't have Docker installed on your local machine.
If not, and you're using a Linux distribution, then use its package manager to install Docker.

If you're not using Linux, then grab a copy of https://docs.docker.com/docker-for-mac/[Docker for Mac] or https://www.docker.com/products/docker#/windows[Docker for Windows], depending which platform you're using.
The installers do an excellent job of making the setup pretty painless.

With Docker installed, we're now able to start building our setup.

== The Docker Setup

Most PHP applications, at their most basic, are composed of three parts:

* A web server (commonly Nginx or Apache)
* A PHP runtime (most often using PHP-FPM these days)
* A database server (usually MySQL, PostgreSQL, or SQLite)

This can be visualized in the illustration below.
Sure, there are a host of other components, such as ElasticSearch, caching, and logging servers, but I'm sticking to the basics.

image::docker-local-development-environment-simple-illustration.jpg[Visualisation of a location development environment using Docker]

Our setup's going to mirror that, having a container for each component which we've listed above.
Let's start with the web server configuration.

== The Web Server Container

In the root directory of your project, create a new file, called `docker-compose.yml`.
In there, add the following configuration:

[source,yaml]
----
version: '2'

volumes:
  database_data:
    driver: local

services:
  nginx:
    image: nginx:latest
    ports:
      - 8080:80
    volumes:
      - ./docker/nginx/default.conf:/etc/nginx/conf.d/default.conf
    volumes_from:
      - php
----

The configuration starts off by specifying that we're using https://docs.docker.com/compose/compose-file/#/version-2[version 2 of the Docker Compose file format].
This is important as using version 2 requires less work on our part, in comparison with version 1.

It next sets up http://container-solutions.com/understanding-volumes-docker/[a persistable filesystem volume], which will be used later in the MySQL container.
This is important to be aware of as, by default, filesystems in a Docker container are setup to be read-only.

Given that, any changes made aren't permanent.
When a container restarts, the original files will be restored and any new files will be removed.
Not a great thing when working with databases, or other storage mechanisms.

We next define an element called `services`.
This element lists the definitions of the three containers which will make up our build, and start defining the Nginx container.

What this does is to create a container called `nginx`, which can be referred to by the other containers using the hostname `nginx`.
It will use the latest, official, Docker Nginx container image as the base for the container.
After that, we map port 80 in the container to port 8080 on our host machine.
This way, when we're finished, we'll be able to access our application by navigating to `+http://localhost:8080+`.

It next copies `./docker/nginx/default.conf` from the local filesystem to `/etc/nginx/conf.d/default.conf` in the container's filesystem.
default.conf provides the core configuration for Nginx.
To save space, I've not included it here.
However, you can find it https://raw.githubusercontent.com/settermjd/docker-for-local-development/master/docker/nginx/default.conf[in the repository for this tutorial].

Finally, the container gets access to a filesystem volume in the PHP container, which we'll see next.
This will let us develop locally on our host machine, yet use the code in the Nginx server.

== The PHP Container

The configuration for the PHP container, below, is rather similar to that of the Nginx container.

[source,yaml]
----
php:
  build: ./docker/php/
  expose:
    - 9000
  volumes:
    - .:/var/www/html
----

You can see that it starts off by naming the container `php`, which sets the container's hostname.
The `build` directive tells it to use a configuration file, called `Dockerfile`, located in `./docker/php` which contains the following instructions:

[source,yaml]
----
FROM php:7.0-fpm

RUN docker-php-ext-install pdo_mysql \
    && docker-php-ext-install json
----

This states that our container is based on the official PHP 7 image from Docker Hub, which uses PHP-FPM.
I'm keeping things as official as possible.

In addition to using the default image, I've also added some PHP extensions, by calling the `docker-php-ext-install` command.
Specifically, I'm ensuring that `pdo_mysql` and `json` are available in the container.

NOTE: This command does not install an extension's dependencies.
It only installs the extension, if the dependencies are available.

Going back to docker-compose.yml, it next exposes the container's port 9000.
If this is your first time reading about Docker, that might not make a lot of sense.
What it's doing is exposing the container's port 9000, a lot like when we allow access to a port through a firewall.

If you've had a look at `./docker/nginx/default.conf` in the source repository, you'll have see that it contains the directive: `fastcgi_pass php:9000;`.
This allows the Nginx container to pass off requests to PHP in the PHP container.

Lastly, we're mapping a directory on our development machine to a directory in the container, for use in the container.
This will also be available in the Nginx container, thanks to the `volumes_from` directive, which we saw earlier.

This has the effect of sharing your local directory with the container, rather like https://www.vagrantup.com/docs/synced-folders/[Vagrant's shared folders], which makes local development quite efficient.
When you make a change in your development environment, whether in a text editor, or an IDE such as PhpStorm, the changes will be available in the container as well.
There is no need to manually copy or sync files between your development environment and the container.

Thanks to <<comment-3315897090,Tom Lobato>> and <<comment-3064099019,Rutvik Prajapati>> for pointing out that I wasn't as clear here as I should have been.

== The MySQL Server

Now, for the final piece, the MySQL container.

[source,yaml]
----
mysql:
  image: mysql:latest
  expose:
    - 3306
  volumes:
    - database_data:/var/lib/mysql
  environment:
    MYSQL_ROOT_PASSWORD: secret
    MYSQL_DATABASE: project
    MYSQL_USER: project
    MYSQL_PASSWORD: project
----

As with the other containers, we've given it a name (and hostname): `mysql`.
We are using the official MySQL container image, from https://hub.docker.com/[DockerHub] as the foundation for it and exposing port 3306, the standard MySQL port, which was referred to in the PHP container.

Next, using the `volumes` directive, we're making any changes in `/var/lib/mysql`, where MySQL will store its data files, permanent.
We then finish up setting four environment variables, which the MySQL server needs.
These are for the root MySQL password, the name of the database to create, and an application username and password.

== Booting the Docker Containers

Now that we've configured the containers let's make use of them.
From the terminal, in the root directory of your project, run the following command:

----
docker-compose up -d
----

What this will do, is to look for `docker-compose.yml` in the same directory for the instructions it needs to build the containers, and then start them.
After they start, Docker will go into daemon mode.

When you run this, you'll see each container being created and started.
If this is the first time that you've created and launched the containers, then the base images will have to be first downloaded, before the containers can be created on top of them.

This may take a few minutes, based on the speed of your connection.
However, after the first time, they'll usually be booted in under a minute.

With them created, you're ready to use them.
At this point, in a browser, navigate to `http://localhost:8080`, where you'll see your application running, which renders https://matthewsetter.com/zend-expressive-introduction[the standard Zend Expressive Skeleton Project home page].

== Conclusion

That's how to use Docker to build a local development environment for Zend Expressive (or any PHP) application.
We have one container which runs PHP, one which runs Nginx, and one which runs MySQL;
all able to talk to each other as needed.

You could say that we can now build environments a lot like we can build codeâ€”in a modular fashion.
It's a fair way of thinking about it.
Why shouldn't we be able to do so?

I appreciate this has been quite a rapid run-through.
But it has covered the basics required to get you started.
We haven't looked too deeply into how Docker works, nor gone too far beyond the basics.
