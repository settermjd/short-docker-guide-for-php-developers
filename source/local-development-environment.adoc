= So How Do I Build a Local Development Environment?

Building a development environment which mirrors production (or any other environment) hasn't, historically, been an easy task.
But with Docker, it's become, _almost_, trivial.

In this chapter, I'll step you through how to setup a local development environment using Docker for developing PHP applications.

If you're keen to find out the latest, and best, way to create a development environment, one which you _can_ be up and running within less than 20 minutes, let's get started.

== The Docker Setup

The PHP application logically needs PHP.
It will also need a decent webserver, so that both static and dynamic content can be served.
For that, I've chosen NGINX over Apache.
Finally, it also needs to retrieve content from a database. 
For this task, I've chosen MySQL.

This can be visualized in the illustration below.
Sure, there are a host of other components, such as _ElasticSearch_, caching, and logging servers. 
However, I'm sticking to the essentials.

image::docker-design.png[The Docker Container Setup]

Given these needs, the setup will have three containers:

- One container for PHP
- One container for NGINX; and
- One container for MySQL

This follows the Docker ethos of one process (or service) per container.
In addition the setup will create place the three containers into a virtual network, so that they can communicate freely with one another.
Finally, it will expose port 80 of the NGINX container as port 8080 on the local machine (or host), so that the application can be used.

image::docker-local-development-environment-simple-illustration.jpg[Visualisation of a location development environment using Docker]

Let's start with the web server configuration.

== The Web Server Container

In the root directory of your project, create a new file, called `docker-compose.yml`.
In there, add the following configuration:

[source,yaml]
----
version: '3'

volumes:
  database_data:
    driver: local

services:
  nginx:
    image: nginx:latest
    ports:
      - 8080:80
    volumes:
      - ./docker/nginx/default.conf:/etc/nginx/conf.d/default.conf
    volumes_from:
      - php
----

The configuration starts off by specifying that we're using https://docs.docker.com/compose/compose-file/#/version-2[version 2 of the Docker Compose file format].
This is important as using version 2 requires less work on our part, in comparison with version 1.

It next sets up http://container-solutions.com/understanding-volumes-docker/[a persistable filesystem volume], which will be used later in the MySQL container.
This is important to be aware of as, by default, filesystems in a Docker container are setup to be read-only.

Given that, any changes made aren't permanent.
When a container restarts, the original files will be restored and any new files will be removed.
Not a great thing when working with databases, or other storage mechanisms.

We next define an element called `services`.
This element lists the definitions of the three containers which will make up our build, and start defining the Nginx container.

What this does is to create a container called `nginx`, which can be referred to by the other containers using the hostname `nginx`.
It will use the latest, official, Docker Nginx container image as the base for the container.
After that, we map port 80 in the container to port 8080 on our host machine.
This way, when we're finished, we'll be able to access our application by navigating to `+http://localhost:8080+`.

It next copies `./docker/nginx/default.conf` from the local filesystem to `/etc/nginx/conf.d/default.conf` in the container's filesystem.
default.conf provides the core configuration for Nginx.
To save space, I've not included it here.
However, you can find it https://raw.githubusercontent.com/settermjd/docker-for-local-development/master/docker/nginx/default.conf[in the repository for this tutorial].

Finally, the container gets access to a filesystem volume in the PHP container, which we'll see next.
This will let us develop locally on our host machine, yet use the code in the Nginx server.

== The PHP Container

The configuration for the PHP container, below, is rather similar to that of the Nginx container.

[source,yaml]
----
php:
  build: ./docker/php/
  expose:
    - 9000
  volumes:
    - .:/var/www/html
----

You can see that it starts off by naming the container `php`, which sets the container's hostname.
The `build` directive tells it to use a configuration file, called `Dockerfile`, located in `./docker/php` which contains the following instructions:

[source,yaml]
----
FROM php:7.0-fpm

RUN docker-php-ext-install pdo_mysql \
    && docker-php-ext-install json
----

This states that our container is based on the official PHP 7 image from Docker Hub, which uses PHP-FPM.
I'm keeping things as official as possible.

In addition to using the default image, I've also added some PHP extensions, by calling the `docker-php-ext-install` command.
Specifically, I'm ensuring that `pdo_mysql` and `json` are available in the container.

NOTE: This command does not install an extension's dependencies.
It only installs the extension, if the dependencies are available.

Going back to docker-compose.yml, it next exposes the container's port 9000.
If this is your first time reading about Docker, that might not make a lot of sense.
What it's doing is exposing the container's port 9000, a lot like when we allow access to a port through a firewall.

If you've had a look at `./docker/nginx/default.conf` in the source repository, you'll have see that it contains the directive: `fastcgi_pass php:9000;`.
This allows the Nginx container to pass off requests to PHP in the PHP container.

Lastly, we're mapping a directory on our development machine to a directory in the container, for use in the container.
This will also be available in the Nginx container, thanks to the `volumes_from` directive, which we saw earlier.

This has the effect of sharing your local directory with the container, rather like https://www.vagrantup.com/docs/synced-folders/[Vagrant's shared folders], which makes local development quite efficient.
When you make a change in your development environment, whether in a text editor, or an IDE such as PhpStorm, the changes will be available in the container as well.
There is no need to manually copy or sync files between your development environment and the container.

== The MySQL Server

Now, for the final piece, the MySQL container.

[source,yaml]
----
mysql:
  image: mysql:latest
  expose:
    - 3306
  volumes:
    - database_data:/var/lib/mysql
  environment:
    MYSQL_ROOT_PASSWORD: secret
    MYSQL_DATABASE: project
    MYSQL_USER: project
    MYSQL_PASSWORD: project
----

As with the other containers, we've given it a name (and hostname): `mysql`.
We are using the official MySQL container image, from https://hub.docker.com/[DockerHub] as the foundation for it and exposing port 3306, the standard MySQL port, which was referred to in the PHP container.

Next, using the `volumes` directive, we're making any changes in `/var/lib/mysql`, where MySQL will store its data files, permanent.
We then finish up setting four environment variables, which the MySQL server needs.
These are for the root MySQL password, the name of the database to create, and an application username and password.

== Booting the Docker Containers

Now that we've configured the containers let's make use of them.
From the terminal, in the root directory of your project, run the following command:

----
docker-compose up -d
----

What this will do, is to look for `docker-compose.yml` in the same directory for the instructions it needs to build the containers, and then start them.
After they start, Docker will go into daemon mode.

When you run this, you'll see each container being created and started.
If this is the first time that you've created and launched the containers, then the base images will have to be first downloaded, before the containers can be created on top of them.

This may take a few minutes, based on the speed of your connection.
However, after the first time, they'll usually be booted in under a minute.

With them created, you're ready to use them.
At this point, in a browser, navigate to `http://localhost:8080`, where you'll see your application running, which renders https://matthewsetter.com/zend-expressive-introduction[the standard Zend Expressive Skeleton Project home page].

== Chapter Recap

That's how to use Docker to build a local development environment for Zend Expressive (or any PHP) application.
We have one container which runs PHP, one which runs Nginx, and one which runs MySQL;
all able to talk to each other as needed.

You could say that we can now build environments a lot like we can build codeâ€”in a modular fashion.
It's a fair way of thinking about it.
Why shouldn't we be able to do so?

I appreciate this has been quite a rapid run-through.
But it has covered the basics required to get you started.
We haven't looked too deeply into how Docker works, nor gone too far beyond the basics.
